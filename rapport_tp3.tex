\documentclass[11pt,a4paper]{article}

% Packages essentiels
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\geometry{left=2.5cm,right=2.5cm,top=2cm,bottom=2cm}
\usepackage{graphicx}
\usepackage{float}
\usepackage{booktabs}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}

% Configuration listings
\lstset{
    language=bash,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{gray},
    frame=single,
    breaklines=true,
    numbers=left,
    numberstyle=\tiny\color{gray}
}

% Configuration hyperref
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=cyan,
}

% Titre
\title{\textbf{TP3 - Évaluation des Performances de Mémoires Caches} \\ \large Architecture des Microprocesseurs - ES201}
\author{ELADEB Mohamed, SAFI Ahmed, KLILA Mohamed, ABID Mahdi, BOUGUERBA Nazih}
\date{\today}

\begin{document}

\maketitle

%=============================================================================
\section{Introduction}
%=============================================================================

Ce TP évalue les performances de 2 configurations de mémoires caches (C1 : direct-mapped, C2 : set-associative) pour 4 algorithmes de multiplication de matrices (128×128). Le paramètre analysé est le \textbf{miss rate} : rapport entre défauts de cache et accès totaux.

\textbf{Outils :} gem5 v23.0.0.1 (RISC-V 64 bits), scripts Bash pour automatisation.

\textbf{Programmes testés :}
\begin{itemize}
    \item P1 (\texttt{normale}) : Multiplication classique (i-j-k)
    \item P2 (\texttt{pointer}) : Accès via pointeurs
    \item P3 (\texttt{tempo}) : Cache blocking
    \item P4 (\texttt{unrol}) : Loop unrolling
\end{itemize}

%=============================================================================
\section{Question 1 : Paramètres gem5}
%=============================================================================

\subsection{Configurations de caches}

\begin{table}[H]
\centering
\caption{Configurations de caches testées}
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{Config} & \textbf{I-cache} & \textbf{D-cache} & \textbf{L2} & \textbf{Block} \\ 
\midrule
C1 & 4KB direct & 4KB direct & 32KB direct & 32B \\
C2 & 4KB direct & 4KB 2-way & 32KB 4-way & 32B \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Tableau 8 - Paramètres gem5}

\begin{table}[H]
\centering
\caption{Paramètres de cache pour chaque configuration}
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{Config} & \textbf{IL1} & \textbf{DL1} & \textbf{UL2} \\ 
\midrule
C1 & 4kB, 1-way, LRU, 32B & 4kB, 1-way, LRU, 32B & 32kB, 1-way, LRU, 32B \\
C2 & 4kB, 1-way, LRU, 32B & 4kB, 2-way, LRU, 32B & 32kB, 4-way, LRU, 32B \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Implémentation (se\_A7.py) :}
\begin{lstlisting}[language=Python]
system.cache_line_size = 32
system.cpu.icache = L1ICache()  # 4kB, assoc=1
system.cpu.dcache = L1DCache()  # 4kB, assoc=1
system.l2cache = L2Cache()      # 32kB, assoc=1

if args.cacheconfig == "C2":
    system.cpu.dcache.assoc = 2  # 2-way
    system.l2cache.assoc = 4     # 4-way
\end{lstlisting}

%=============================================================================
\section{Question 2 : Méthodologie et Résultats}
%=============================================================================

\subsection{Méthodologie}

\textbf{Script simulations.sh} (lance les 8 simulations) :
\begin{lstlisting}
#!/bin/bash
PROGS=("normale.riscv" "pointer.riscv" "tempo.riscv" "unrol.riscv")
CONFIGS=("C1" "C2")
GEM5="/root/gem5/build/RISCV/gem5.opt"

for prog in "${PROGS[@]}"; do
    for cfg in "${CONFIGS[@]}"; do
        out="m5out_${prog}_${cfg}"
        $GEM5 --outdir="$out" se_A7.py --cmd "$prog" --cacheconfig "$cfg"
    done
done
\end{lstlisting}

\textbf{Script resultats.sh} (extrait les miss rates) :
\begin{lstlisting}
get_stat() { grep "^$2" "$1/stats.txt" | awk '{print $2}' }
percent() { awk -v m=$1 -v a=$2 'BEGIN {printf "%.2f",m/a*100}' }

# Exemple I-cache
m=$(get_stat "m5out_prog_C1" "system.cpu.icache.overallMisses::total")
a=$(get_stat "m5out_prog_C1" "system.cpu.icache.overallAccesses::total")
echo "Miss rate: $(percent $m $a)%"
\end{lstlisting}

\subsection{Résultats}

\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{tp3.png}
\caption{Résultats des simulations - Miss rates pour IL1, DL1 et UL2}
\end{figure}

\subsubsection{Tableau 9 - Instruction Cache (IL1)}

\begin{table}[H]
\centering
\caption{Instruction Cache Miss Rate (\%)}
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{Programme} & \textbf{C1} & \textbf{C2} & \textbf{Δ} \\ 
\midrule
P1 (normale) & 2.16 & 2.16 & 0.00 \\
P2 (pointer) & 0.07 & 0.07 & 0.00 \\
P3 (tempo)   & 2.33 & 2.32 & -0.01 \\
P4 (unrol)   & 0.17 & 0.17 & 0.00 \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Tableau 10 - Data Cache (DL1)}

\begin{table}[H]
\centering
\caption{Data Cache Miss Rate (\%)}
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{Programme} & \textbf{C1} & \textbf{C2} & \textbf{Δ} \\ 
\midrule
P1 (normale) & 51.43 & 44.65 & \textcolor{green}{-6.78} \\
P2 (pointer) & 51.47 & 45.83 & \textcolor{green}{-5.64} \\
P3 (tempo)   & 50.99 & 44.18 & \textcolor{green}{-6.81} \\
P4 (unrol)   & 51.53 & 43.98 & \textcolor{green}{-7.55} \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Tableau 11 - L2 Cache (UL2)}

\begin{table}[H]
\centering
\caption{L2 Cache Miss Rate (\%)}
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{Programme} & \textbf{C1} & \textbf{C2} & \textbf{Δ} \\ 
\midrule
P1 (normale) & 51.51 & 45.66 & \textcolor{green}{-5.85} \\
P2 (pointer) & 50.99 & 44.59 & \textcolor{green}{-6.40} \\
P3 (tempo)   & 51.55 & 45.92 & \textcolor{green}{-5.63} \\
P4 (unrol)   & 51.51 & 46.16 & \textcolor{green}{-5.35} \\
\bottomrule
\end{tabular}
\end{table}

%=============================================================================
\section{Analyse des Résultats}
%=============================================================================

\subsection{Cache d'instructions (Tableau 9)}

\textbf{Observations :}
\begin{itemize}
    \item Miss rates très faibles : 0.07\% à 2.33\%
    \item Aucun gain C1→C2 (IL1 reste direct-mapped)
    \item \texttt{pointer} meilleur (0.07\%) : code réutilisé 1500× (1364 misses / 2M accès)
\end{itemize}

\textbf{Explication :} Le code ($\sim$500B-1kB) tient entièrement dans IL1 (4kB). Localité temporelle exceptionnelle : boucles exécutées $N^3 \approx 2M$ fois.

\subsection{Cache de données (Tableau 10)}

\textbf{Observations :}
\begin{itemize}
    \item Miss rates élevés : 44\%-52\% (thrashing)
    \item Gain C1→C2 : 5.6\% à 7.5\% (\texttt{unrol} meilleur)
    \item Performances similaires entre algorithmes
\end{itemize}

\textbf{Explication :} Problème de capacité. 3 matrices = $3 \times 128 \times 128 \times 8 = 384$ kB $>>$ DL1 (4 kB). Ratio 96:1. La 2-way associativité réduit les conflict misses mais ne résout pas le problème fondamental.

\subsection{L2 Cache (Tableau 11)}

\textbf{Observations :}
\begin{itemize}
    \item Miss rates élevés : 44\%-52\% (similaire au DL1)
    \item Gain C1→C2 modéré : 5.3\% à 6.4\%
\end{itemize}

\textbf{Explication :} Même problème de capacité. 384 kB $>>$ L2 (32 kB), ratio 12:1. La majorité des accès L2 vont en RAM.

%=============================================================================
\section{Question 3 : Localité du Code}
%=============================================================================

\textbf{Les 4 algorithmes présentent-ils une bonne localité de références pour le code ?}

\subsection{Réponse : OUI, excellente localité}

\textbf{Justifications :}

\begin{enumerate}
    \item \textbf{Contraste instructions vs données} (Tableau \ref{tab:contraste}) :
    
\begin{table}[H]
\centering
\caption{Contraste I-cache vs D-cache}
\label{tab:contraste}
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{Programme} & \textbf{I-cache} & \textbf{D-cache} & \textbf{Facteur} \\ 
\midrule
normale & 2.16\%  & 51.43\% & ×24 \\
pointer & 0.07\%  & 51.47\% & ×735 \\
tempo   & 2.33\%  & 50.99\% & ×22 \\
unrol   & 0.17\%  & 51.53\% & ×303 \\
\bottomrule
\end{tabular}
\end{table}

Le cache d'instructions est \textbf{22 à 735 fois plus efficace}.

    \item \textbf{Localité temporelle :} Boucles exécutées $N^3 = 2.1M$ fois. Pour \texttt{pointer} : code chargé une fois, réutilisé 1500 fois.
    
    \item \textbf{Taille code $\ll$ cache :} Code actif (500B-1kB) $<<$ IL1 (4kB). Aucun capacity miss.
    
    \item \textbf{Pas de gain C1→C2 :} Code trop petit, aucun conflict miss. L'associativité est inutile (déjà optimal).
\end{enumerate}

\subsection{Conclusion : Localité asymétrique}

\begin{center}
\begin{tabular}{ccc}
\textbf{Instructions} & & \textbf{Données} \\
\textcolor{green}{Excellente (0.07-2.33\%)} & vs & \textcolor{red}{Médiocre (44-52\%)} \\
\end{tabular}
\end{center}

Typique du calcul scientifique : petit noyau de code réutilisé massivement sur gros volume de données. Le bottleneck est la \textbf{mémoire données}, pas le code.

%=============================================================================
\section{Recommandations}
%=============================================================================

Pour améliorer les performances :
\begin{itemize}
    \item \textbf{Augmenter L2 à 512kB-1MB} (contenir les 3 matrices)
    \item \textbf{Augmenter DL1 à 32kB} (optimiser cache blocking)
    \item \textbf{Ajouter L3 de 2-4MB}
    \item \textbf{L2 8-16-way associative}
\end{itemize}

Avec ces configs, \texttt{tempo} (blocking) devrait montrer son avantage (miss rate réduit à 20-30\%).

%=============================================================================
\section{Conclusion}
%=============================================================================

Ce TP démontre que :
\begin{enumerate}
    \item Le code a une \textbf{excellente localité} (miss rate <2.5\%)
    \item Les données ont une \textbf{mauvaise localité} (miss rate >44\%)
    \item Le facteur limitant est la \textbf{capacité}, pas l'organisation
    \item L'associativité apporte un gain modéré (5-7\%) mais insuffisant
\end{enumerate}

Pour les applications de calcul intensif sur grandes données, la \textbf{capacité des caches} est critique.

%=============================================================================
\section*{Annexes}
%=============================================================================

\textbf{Code source :} \url{https://github.com/medm3alem/TP3}

\textbf{Fichiers :}
\begin{itemize}
    \item \texttt{simulations.sh} : Lancement des 8 simulations
    \item \texttt{resultats.sh} : Extraction des miss rates
    \item \texttt{se\_A7.py} : Configuration gem5
    \item 8 dossiers \texttt{m5out\_*} : Statistiques complètes (1400+ lignes/fichier)
\end{itemize}

\end{document}
